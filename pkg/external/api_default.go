/*
Nextlinux Enterprise API Server

This is the Nextlinux Enterprise API. It provides additional external API routes and functionality for enterprise users.

API version: 0.2.1
Contact: dev@nextlinux.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package external

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
	"os"
	"reflect"
)

// Linger please
var (
	_ context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAddActionPlanRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	actionPlan *ActionPlan
}

func (r ApiAddActionPlanRequest) ActionPlan(actionPlan ActionPlan) ApiAddActionPlanRequest {
	r.actionPlan = &actionPlan
	return r
}

func (r ApiAddActionPlanRequest) Execute() (*ActionPlan, *http.Response, error) {
	return r.ApiService.AddActionPlanExecute(r)
}

/*
AddActionPlan Submits an Action Plan

Submits an Action Plan and saves upon completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddActionPlanRequest
*/
func (a *DefaultApiService) AddActionPlan(ctx context.Context) ApiAddActionPlanRequest {
	return ApiAddActionPlanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionPlan
func (a *DefaultApiService) AddActionPlanExecute(r ApiAddActionPlanRequest) (*ActionPlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddActionPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionPlan == nil {
		return localVarReturnValue, nil, reportError("actionPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	application *Application
	xNextlinuxAccount *string
}

func (r ApiAddApplicationRequest) Application(application Application) ApiAddApplicationRequest {
	r.application = &application
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddApplicationRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddApplicationRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiAddApplicationRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.AddApplicationExecute(r)
}

/*
AddApplication Create an application

Create an application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddApplicationRequest
*/
func (a *DefaultApiService) AddApplication(ctx context.Context) ApiAddApplicationRequest {
	return ApiAddApplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Application
func (a *DefaultApiService) AddApplicationExecute(r ApiAddApplicationRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.application == nil {
		return localVarReturnValue, nil, reportError("application is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.application
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersion *ApplicationVersion
	xNextlinuxAccount *string
}

func (r ApiAddApplicationVersionRequest) ApplicationVersion(applicationVersion ApplicationVersion) ApiAddApplicationVersionRequest {
	r.applicationVersion = &applicationVersion
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiAddApplicationVersionRequest) Execute() (*ApplicationVersion, *http.Response, error) {
	return r.ApiService.AddApplicationVersionExecute(r)
}

/*
AddApplicationVersion Create an application version

Create an application version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @return ApiAddApplicationVersionRequest
*/
func (a *DefaultApiService) AddApplicationVersion(ctx context.Context, applicationId string) ApiAddApplicationVersionRequest {
	return ApiAddApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return ApplicationVersion
func (a *DefaultApiService) AddApplicationVersionExecute(r ApiAddApplicationVersionRequest) (*ApplicationVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddApplicationVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationVersion == nil {
		return localVarReturnValue, nil, reportError("applicationVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.applicationVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddArtifactToApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	artifactRequest *ArtifactAssociationRequest
	xNextlinuxAccount *string
}

func (r ApiAddArtifactToApplicationVersionRequest) ArtifactRequest(artifactRequest ArtifactAssociationRequest) ApiAddArtifactToApplicationVersionRequest {
	r.artifactRequest = &artifactRequest
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddArtifactToApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddArtifactToApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiAddArtifactToApplicationVersionRequest) Execute() (*ArtifactAssociationResponse, *http.Response, error) {
	return r.ApiService.AddArtifactToApplicationVersionExecute(r)
}

/*
AddArtifactToApplicationVersion Add an artifact to an application version

Add artifact to given application_id and application_version_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiAddArtifactToApplicationVersionRequest
*/
func (a *DefaultApiService) AddArtifactToApplicationVersion(ctx context.Context, applicationId string, applicationVersionId string) ApiAddArtifactToApplicationVersionRequest {
	return ApiAddArtifactToApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
//  @return ArtifactAssociationResponse
func (a *DefaultApiService) AddArtifactToApplicationVersionExecute(r ApiAddArtifactToApplicationVersionRequest) (*ArtifactAssociationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactAssociationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddArtifactToApplicationVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.artifactRequest == nil {
		return localVarReturnValue, nil, reportError("artifactRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.artifactRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddCorrectionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	correction *Correction
	xNextlinuxAccount *string
}

func (r ApiAddCorrectionRequest) Correction(correction Correction) ApiAddCorrectionRequest {
	r.correction = &correction
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddCorrectionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddCorrectionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiAddCorrectionRequest) Execute() ([]Correction, *http.Response, error) {
	return r.ApiService.AddCorrectionExecute(r)
}

/*
AddCorrection Create a correction record

Add a correction record that will be used to fix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddCorrectionRequest
*/
func (a *DefaultApiService) AddCorrection(ctx context.Context) ApiAddCorrectionRequest {
	return ApiAddCorrectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Correction
func (a *DefaultApiService) AddCorrectionExecute(r ApiAddCorrectionRequest) ([]Correction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Correction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddCorrection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corrections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.correction == nil {
		return localVarReturnValue, nil, reportError("correction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.correction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddInventoryClusterRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	cluster *InventoryCluster
	xNextlinuxAccount *string
}

func (r ApiAddInventoryClusterRequest) Cluster(cluster InventoryCluster) ApiAddInventoryClusterRequest {
	r.cluster = &cluster
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddInventoryClusterRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddInventoryClusterRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiAddInventoryClusterRequest) Execute() (*InventoryCluster, *http.Response, error) {
	return r.ApiService.AddInventoryClusterExecute(r)
}

/*
AddInventoryCluster Create a cluster inventory

Create a new cluster inventory with the provided configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddInventoryClusterRequest
*/
func (a *DefaultApiService) AddInventoryCluster(ctx context.Context) ApiAddInventoryClusterRequest {
	return ApiAddInventoryClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InventoryCluster
func (a *DefaultApiService) AddInventoryClusterExecute(r ApiAddInventoryClusterRequest) (*InventoryCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddInventoryCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cluster == nil {
		return localVarReturnValue, nil, reportError("cluster is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.cluster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddRuntimeComplianceCheckRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	checkType *string
	imageDigest *string
	xNextlinuxAccount *string
	result *string
	pod *string
	namespace *string
	imageTag *string
	startTime *time.Time
	endTime *time.Time
	resultFile **os.File
	reportFile **os.File
}

// The type of runtime compliance check
func (r ApiAddRuntimeComplianceCheckRequest) CheckType(checkType string) ApiAddRuntimeComplianceCheckRequest {
	r.checkType = &checkType
	return r
}
// The digest of the pod the check was run against
func (r ApiAddRuntimeComplianceCheckRequest) ImageDigest(imageDigest string) ApiAddRuntimeComplianceCheckRequest {
	r.imageDigest = &imageDigest
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddRuntimeComplianceCheckRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiAddRuntimeComplianceCheckRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}
// The result of the runtime compliance check
func (r ApiAddRuntimeComplianceCheckRequest) Result(result string) ApiAddRuntimeComplianceCheckRequest {
	r.result = &result
	return r
}
// The pod the check was run against
func (r ApiAddRuntimeComplianceCheckRequest) Pod(pod string) ApiAddRuntimeComplianceCheckRequest {
	r.pod = &pod
	return r
}
// The namespace of the pod the check was run against
func (r ApiAddRuntimeComplianceCheckRequest) Namespace(namespace string) ApiAddRuntimeComplianceCheckRequest {
	r.namespace = &namespace
	return r
}
// The tag of the image in the pod the check was run against
func (r ApiAddRuntimeComplianceCheckRequest) ImageTag(imageTag string) ApiAddRuntimeComplianceCheckRequest {
	r.imageTag = &imageTag
	return r
}
// The type of runtime compliance check
func (r ApiAddRuntimeComplianceCheckRequest) StartTime(startTime time.Time) ApiAddRuntimeComplianceCheckRequest {
	r.startTime = &startTime
	return r
}
// The type of runtime compliance check
func (r ApiAddRuntimeComplianceCheckRequest) EndTime(endTime time.Time) ApiAddRuntimeComplianceCheckRequest {
	r.endTime = &endTime
	return r
}
// The file with the check results
func (r ApiAddRuntimeComplianceCheckRequest) ResultFile(resultFile *os.File) ApiAddRuntimeComplianceCheckRequest {
	r.resultFile = &resultFile
	return r
}
// The file with the check port
func (r ApiAddRuntimeComplianceCheckRequest) ReportFile(reportFile *os.File) ApiAddRuntimeComplianceCheckRequest {
	r.reportFile = &reportFile
	return r
}

func (r ApiAddRuntimeComplianceCheckRequest) Execute() (*RuntimeComplianceCheck, *http.Response, error) {
	return r.ApiService.AddRuntimeComplianceCheckExecute(r)
}

/*
AddRuntimeComplianceCheck Post a runtime compliance check

Post a runtime compliance check

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddRuntimeComplianceCheckRequest
*/
func (a *DefaultApiService) AddRuntimeComplianceCheck(ctx context.Context) ApiAddRuntimeComplianceCheckRequest {
	return ApiAddRuntimeComplianceCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RuntimeComplianceCheck
func (a *DefaultApiService) AddRuntimeComplianceCheckExecute(r ApiAddRuntimeComplianceCheckRequest) (*RuntimeComplianceCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RuntimeComplianceCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddRuntimeComplianceCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtime_compliance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkType == nil {
		return localVarReturnValue, nil, reportError("checkType is required and must be specified")
	}
	if r.imageDigest == nil {
		return localVarReturnValue, nil, reportError("imageDigest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	localVarFormParams.Add("check_type", parameterToString(*r.checkType, ""))
	localVarFormParams.Add("image_digest", parameterToString(*r.imageDigest, ""))
	if r.result != nil {
		localVarFormParams.Add("result", parameterToString(*r.result, ""))
	}
	if r.pod != nil {
		localVarFormParams.Add("pod", parameterToString(*r.pod, ""))
	}
	if r.namespace != nil {
		localVarFormParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.imageTag != nil {
		localVarFormParams.Add("image_tag", parameterToString(*r.imageTag, ""))
	}
	if r.startTime != nil {
		localVarFormParams.Add("start_time", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarFormParams.Add("end_time", parameterToString(*r.endTime, ""))
	}
	var resultFileLocalVarFormFileName string
	var resultFileLocalVarFileName     string
	var resultFileLocalVarFileBytes    []byte

	resultFileLocalVarFormFileName = "result_file"

	var resultFileLocalVarFile *os.File
	if r.resultFile != nil {
		resultFileLocalVarFile = *r.resultFile
	}
	if resultFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(resultFileLocalVarFile)
		resultFileLocalVarFileBytes = fbs
		resultFileLocalVarFileName = resultFileLocalVarFile.Name()
		resultFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: resultFileLocalVarFileBytes, fileName: resultFileLocalVarFileName, formFileName: resultFileLocalVarFormFileName})
	var reportFileLocalVarFormFileName string
	var reportFileLocalVarFileName     string
	var reportFileLocalVarFileBytes    []byte

	reportFileLocalVarFormFileName = "report_file"

	var reportFileLocalVarFile *os.File
	if r.reportFile != nil {
		reportFileLocalVarFile = *r.reportFile
	}
	if reportFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(reportFileLocalVarFile)
		reportFileLocalVarFileBytes = fbs
		reportFileLocalVarFileName = reportFileLocalVarFile.Name()
		reportFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: reportFileLocalVarFileBytes, fileName: reportFileLocalVarFileName, formFileName: reportFileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOperationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiCreateOperationRequest) Execute() (*SourceImportOperation, *http.Response, error) {
	return r.ApiService.CreateOperationExecute(r)
}

/*
CreateOperation Begin the import of a source code repository analyzed by Syft into the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOperationRequest
*/
func (a *DefaultApiService) CreateOperation(ctx context.Context) ApiCreateOperationRequest {
	return ApiCreateOperationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SourceImportOperation
func (a *DefaultApiService) CreateOperationExecute(r ApiCreateOperationRequest) (*SourceImportOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceImportOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDelInventoryClusterByNameRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	clusterName string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDelInventoryClusterByNameRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiDelInventoryClusterByNameRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiDelInventoryClusterByNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DelInventoryClusterByNameExecute(r)
}

/*
DelInventoryClusterByName Delete a configured inventory clusters by cluster_name

Removes a configured cluster for reporting image inventory by cluster_name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return ApiDelInventoryClusterByNameRequest
*/
func (a *DefaultApiService) DelInventoryClusterByName(ctx context.Context, clusterName string) ApiDelInventoryClusterByNameRequest {
	return ApiDelInventoryClusterByNameRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DelInventoryClusterByNameExecute(r ApiDelInventoryClusterByNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DelInventoryClusterByName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories/clusters/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterToString(r.clusterName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDeleteApplicationRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiDeleteApplicationRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiDeleteApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationExecute(r)
}

/*
DeleteApplication Delete an application by application_id

Delete an application by application_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @return ApiDeleteApplicationRequest
*/
func (a *DefaultApiService) DeleteApplication(ctx context.Context, applicationId string) ApiDeleteApplicationRequest {
	return ApiDeleteApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDeleteApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiDeleteApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiDeleteApplicationVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationVersionExecute(r)
}

/*
DeleteApplicationVersion Delete an application version by application_id and application_version_id

Delete an application version by application_id and application_version_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiDeleteApplicationVersionRequest
*/
func (a *DefaultApiService) DeleteApplicationVersion(ctx context.Context, applicationId string, applicationVersionId string) ApiDeleteApplicationVersionRequest {
	return ApiDeleteApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteApplicationVersionExecute(r ApiDeleteApplicationVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteApplicationVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCorrectionByUuidRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	uuid string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDeleteCorrectionByUuidRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiDeleteCorrectionByUuidRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiDeleteCorrectionByUuidRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCorrectionByUuidExecute(r)
}

/*
DeleteCorrectionByUuid Delete a correction by UUID

Delete a single correction, looked up via it's uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteCorrectionByUuidRequest
*/
func (a *DefaultApiService) DeleteCorrectionByUuid(ctx context.Context, uuid string) ApiDeleteCorrectionByUuidRequest {
	return ApiDeleteCorrectionByUuidRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteCorrectionByUuidExecute(r ApiDeleteCorrectionByUuidRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCorrectionByUuid")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corrections/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSourceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
	force *bool
}

// force delete
func (r ApiDeleteSourceRequest) Force(force bool) ApiDeleteSourceRequest {
	r.force = &force
	return r
}

func (r ApiDeleteSourceRequest) Execute() (*SourceManifest, *http.Response, error) {
	return r.ApiService.DeleteSourceExecute(r)
}

/*
DeleteSource Delete source record from DB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId UUID of source to delete
 @return ApiDeleteSourceRequest
*/
func (a *DefaultApiService) DeleteSource(ctx context.Context, sourceId string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return SourceManifest
func (a *DefaultApiService) DeleteSourceExecute(r ApiDeleteSourceRequest) (*SourceManifest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceManifest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinalizeOperationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	operationId string
	metadata *SourceImportMetadata
}

func (r ApiFinalizeOperationRequest) Metadata(metadata SourceImportMetadata) ApiFinalizeOperationRequest {
	r.metadata = &metadata
	return r
}

func (r ApiFinalizeOperationRequest) Execute() (*SourceManifest, *http.Response, error) {
	return r.ApiService.FinalizeOperationExecute(r)
}

/*
FinalizeOperation Add source records to catalog db

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operationId
 @return ApiFinalizeOperationRequest
*/
func (a *DefaultApiService) FinalizeOperation(ctx context.Context, operationId string) ApiFinalizeOperationRequest {
	return ApiFinalizeOperationRequest{
		ApiService: a,
		ctx: ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//  @return SourceManifest
func (a *DefaultApiService) FinalizeOperationExecute(r ApiFinalizeOperationRequest) (*SourceManifest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceManifest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FinalizeOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources/{operation_id}/finalize"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterToString(r.operationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metadata == nil {
		return localVarReturnValue, nil, reportError("metadata is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metadata
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionPlansRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imageTag *string
	imageDigest *string
	createdAfter *time.Time
	xNextlinuxAccount *string
}

func (r ApiGetActionPlansRequest) ImageTag(imageTag string) ApiGetActionPlansRequest {
	r.imageTag = &imageTag
	return r
}
func (r ApiGetActionPlansRequest) ImageDigest(imageDigest string) ApiGetActionPlansRequest {
	r.imageDigest = &imageDigest
	return r
}
// RFC 3339 formatted UTC timestamp to filter out action plans that were only created after this date
func (r ApiGetActionPlansRequest) CreatedAfter(createdAfter time.Time) ApiGetActionPlansRequest {
	r.createdAfter = &createdAfter
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetActionPlansRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetActionPlansRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetActionPlansRequest) Execute() ([]ActionPlan, *http.Response, error) {
	return r.ApiService.GetActionPlansExecute(r)
}

/*
GetActionPlans Gets a list of submitted action (remediation) plans

Retrieves a list of action plans that have been completed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionPlansRequest
*/
func (a *DefaultApiService) GetActionPlans(ctx context.Context) ApiGetActionPlansRequest {
	return ApiGetActionPlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ActionPlan
func (a *DefaultApiService) GetActionPlansExecute(r ApiGetActionPlansRequest) ([]ActionPlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActionPlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetActionPlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageTag != nil {
		localVarQueryParams.Add("image_tag", parameterToString(*r.imageTag, ""))
	}
	if r.imageDigest != nil {
		localVarQueryParams.Add("image_digest", parameterToString(*r.imageDigest, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("created_after", parameterToString(*r.createdAfter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertSummariesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	page *int32
	limit *int32
	type_ *string
	state *string
	createdAfter *time.Time
	createdBefore *time.Time
	resourceLabel *[]string
	xNextlinuxAccount *string
}

func (r ApiGetAlertSummariesRequest) Page(page int32) ApiGetAlertSummariesRequest {
	r.page = &page
	return r
}
func (r ApiGetAlertSummariesRequest) Limit(limit int32) ApiGetAlertSummariesRequest {
	r.limit = &limit
	return r
}
// Filter for alerts based on the type such as compliance violation
func (r ApiGetAlertSummariesRequest) Type_(type_ string) ApiGetAlertSummariesRequest {
	r.type_ = &type_
	return r
}
// Filter for alerts by current state, defaults to open alerts unless specified
func (r ApiGetAlertSummariesRequest) State(state string) ApiGetAlertSummariesRequest {
	r.state = &state
	return r
}
// Filter for alerts generated after the timestamp
func (r ApiGetAlertSummariesRequest) CreatedAfter(createdAfter time.Time) ApiGetAlertSummariesRequest {
	r.createdAfter = &createdAfter
	return r
}
// Filter for alerts generated before the timestamp
func (r ApiGetAlertSummariesRequest) CreatedBefore(createdBefore time.Time) ApiGetAlertSummariesRequest {
	r.createdBefore = &createdBefore
	return r
}
// Filter for alerts associated with a resource where the label in key&#x3D;value format such as tag&#x3D;docker.io/library/alpine:latest or repository&#x3D;library/alpine
func (r ApiGetAlertSummariesRequest) ResourceLabel(resourceLabel []string) ApiGetAlertSummariesRequest {
	r.resourceLabel = &resourceLabel
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetAlertSummariesRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetAlertSummariesRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetAlertSummariesRequest) Execute() ([]AlertSummary, *http.Response, error) {
	return r.ApiService.GetAlertSummariesExecute(r)
}

/*
GetAlertSummaries List all alert summaries scoped to the account

Returns a paginated list of alert summaries in chronological order from the most to least recently generated alerts. Return alerts in the open state by default. Use query parameters for filtering

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAlertSummariesRequest
*/
func (a *DefaultApiService) GetAlertSummaries(ctx context.Context) ApiGetAlertSummariesRequest {
	return ApiGetAlertSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AlertSummary
func (a *DefaultApiService) GetAlertSummariesExecute(r ApiGetAlertSummariesRequest) ([]AlertSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlertSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAlertSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("created_after", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("created_before", parameterToString(*r.createdBefore, ""))
	}
	if r.resourceLabel != nil {
		t := *r.resourceLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("resource_label", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("resource_label", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	includeVersions *bool
	xNextlinuxAccount *string
}

func (r ApiGetApplicationRequest) IncludeVersions(includeVersions bool) ApiGetApplicationRequest {
	r.includeVersions = &includeVersions
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetApplicationRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetApplicationRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetApplicationRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Get an application by application_id

Get an application by application_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @return ApiGetApplicationRequest
*/
func (a *DefaultApiService) GetApplication(ctx context.Context, applicationId string) ApiGetApplicationRequest {
	return ApiGetApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return Application
func (a *DefaultApiService) GetApplicationExecute(r ApiGetApplicationRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeVersions != nil {
		localVarQueryParams.Add("include_versions", parameterToString(*r.includeVersions, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetApplicationVersionRequest) Execute() (*ApplicationVersion, *http.Response, error) {
	return r.ApiService.GetApplicationVersionExecute(r)
}

/*
GetApplicationVersion Get an application version

Get an application version by application_id and application_version_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiGetApplicationVersionRequest
*/
func (a *DefaultApiService) GetApplicationVersion(ctx context.Context, applicationId string, applicationVersionId string) ApiGetApplicationVersionRequest {
	return ApiGetApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
//  @return ApplicationVersion
func (a *DefaultApiService) GetApplicationVersionExecute(r ApiGetApplicationVersionRequest) (*ApplicationVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplicationVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationVersionSbomRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	artifactTypes *[]string
	xNextlinuxAccount *string
}

func (r ApiGetApplicationVersionSbomRequest) ArtifactTypes(artifactTypes []string) ApiGetApplicationVersionSbomRequest {
	r.artifactTypes = &artifactTypes
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetApplicationVersionSbomRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetApplicationVersionSbomRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetApplicationVersionSbomRequest) Execute() (*ApplicationVersionSbom, *http.Response, error) {
	return r.ApiService.GetApplicationVersionSbomExecute(r)
}

/*
GetApplicationVersionSbom Get the combined sbom for the given application version, optionally filtered by artifact type

Get the combined sbom for the given application version, optionally filtered by artifact type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiGetApplicationVersionSbomRequest
*/
func (a *DefaultApiService) GetApplicationVersionSbom(ctx context.Context, applicationId string, applicationVersionId string) ApiGetApplicationVersionSbomRequest {
	return ApiGetApplicationVersionSbomRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
//  @return ApplicationVersionSbom
func (a *DefaultApiService) GetApplicationVersionSbomExecute(r ApiGetApplicationVersionSbomRequest) (*ApplicationVersionSbom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationVersionSbom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplicationVersionSbom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}/sboms/json"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artifactTypes != nil {
		localVarQueryParams.Add("artifact_types", parameterToString(*r.artifactTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationVersionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetApplicationVersionsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetApplicationVersionsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetApplicationVersionsRequest) Execute() ([]ApplicationVersion, *http.Response, error) {
	return r.ApiService.GetApplicationVersionsExecute(r)
}

/*
GetApplicationVersions List all application verions

List all application verions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @return ApiGetApplicationVersionsRequest
*/
func (a *DefaultApiService) GetApplicationVersions(ctx context.Context, applicationId string) ApiGetApplicationVersionsRequest {
	return ApiGetApplicationVersionsRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return []ApplicationVersion
func (a *DefaultApiService) GetApplicationVersionsExecute(r ApiGetApplicationVersionsRequest) ([]ApplicationVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplicationVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	includeVersions *bool
	xNextlinuxAccount *string
}

func (r ApiGetApplicationsRequest) IncludeVersions(includeVersions bool) ApiGetApplicationsRequest {
	r.includeVersions = &includeVersions
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetApplicationsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetApplicationsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetApplicationsRequest) Execute() ([]Application, *http.Response, error) {
	return r.ApiService.GetApplicationsExecute(r)
}

/*
GetApplications List all applications

List all applications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApplicationsRequest
*/
func (a *DefaultApiService) GetApplications(ctx context.Context) ApiGetApplicationsRequest {
	return ApiGetApplicationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Application
func (a *DefaultApiService) GetApplicationsExecute(r ApiGetApplicationsRequest) ([]Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeVersions != nil {
		localVarQueryParams.Add("include_versions", parameterToString(*r.includeVersions, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComplianceViolationAlertRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	uuid string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetComplianceViolationAlertRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetComplianceViolationAlertRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetComplianceViolationAlertRequest) Execute() (*ComplianceViolationAlert, *http.Response, error) {
	return r.ApiService.GetComplianceViolationAlertExecute(r)
}

/*
GetComplianceViolationAlert Get compliance violation alert by id

Returns a single compliance violation alert object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Identifier for the alert
 @return ApiGetComplianceViolationAlertRequest
*/
func (a *DefaultApiService) GetComplianceViolationAlert(ctx context.Context, uuid string) ApiGetComplianceViolationAlertRequest {
	return ApiGetComplianceViolationAlertRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ComplianceViolationAlert
func (a *DefaultApiService) GetComplianceViolationAlertExecute(r ApiGetComplianceViolationAlertRequest) (*ComplianceViolationAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComplianceViolationAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetComplianceViolationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/compliance_violations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComplianceViolationAlertsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	page *int32
	limit *int32
	state *string
	createdAfter *time.Time
	createdBefore *time.Time
	resourceImageDigest *string
	resourceImageTag *string
	resourceRegistry *string
	resourceRepository *string
	xNextlinuxAccount *string
}

func (r ApiGetComplianceViolationAlertsRequest) Page(page int32) ApiGetComplianceViolationAlertsRequest {
	r.page = &page
	return r
}
func (r ApiGetComplianceViolationAlertsRequest) Limit(limit int32) ApiGetComplianceViolationAlertsRequest {
	r.limit = &limit
	return r
}
// Filter for alerts by current state, defaults to open alerts unless specified
func (r ApiGetComplianceViolationAlertsRequest) State(state string) ApiGetComplianceViolationAlertsRequest {
	r.state = &state
	return r
}
// Filter for alerts generated after the timestamp
func (r ApiGetComplianceViolationAlertsRequest) CreatedAfter(createdAfter time.Time) ApiGetComplianceViolationAlertsRequest {
	r.createdAfter = &createdAfter
	return r
}
// Filter for alerts generated before the timestamp
func (r ApiGetComplianceViolationAlertsRequest) CreatedBefore(createdBefore time.Time) ApiGetComplianceViolationAlertsRequest {
	r.createdBefore = &createdBefore
	return r
}
// Filter for alerts associated with image digest
func (r ApiGetComplianceViolationAlertsRequest) ResourceImageDigest(resourceImageDigest string) ApiGetComplianceViolationAlertsRequest {
	r.resourceImageDigest = &resourceImageDigest
	return r
}
// Filter for alerts generated for the tag
func (r ApiGetComplianceViolationAlertsRequest) ResourceImageTag(resourceImageTag string) ApiGetComplianceViolationAlertsRequest {
	r.resourceImageTag = &resourceImageTag
	return r
}
// Filter for alerts associated with registry
func (r ApiGetComplianceViolationAlertsRequest) ResourceRegistry(resourceRegistry string) ApiGetComplianceViolationAlertsRequest {
	r.resourceRegistry = &resourceRegistry
	return r
}
// Filter for alerts associated with repository
func (r ApiGetComplianceViolationAlertsRequest) ResourceRepository(resourceRepository string) ApiGetComplianceViolationAlertsRequest {
	r.resourceRepository = &resourceRepository
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetComplianceViolationAlertsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetComplianceViolationAlertsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetComplianceViolationAlertsRequest) Execute() ([]ComplianceViolationAlert, *http.Response, error) {
	return r.ApiService.GetComplianceViolationAlertsExecute(r)
}

/*
GetComplianceViolationAlerts List all compliance violation alerts scoped to the account

Returns a paginated list of compliance violation alerts in chronological order from the most to least recently generated alerts. Return alerts in the open state by default. Use query parameters for filtering

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetComplianceViolationAlertsRequest
*/
func (a *DefaultApiService) GetComplianceViolationAlerts(ctx context.Context) ApiGetComplianceViolationAlertsRequest {
	return ApiGetComplianceViolationAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ComplianceViolationAlert
func (a *DefaultApiService) GetComplianceViolationAlertsExecute(r ApiGetComplianceViolationAlertsRequest) ([]ComplianceViolationAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ComplianceViolationAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetComplianceViolationAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/compliance_violations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("created_after", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("created_before", parameterToString(*r.createdBefore, ""))
	}
	if r.resourceImageDigest != nil {
		localVarQueryParams.Add("resource_image_digest", parameterToString(*r.resourceImageDigest, ""))
	}
	if r.resourceImageTag != nil {
		localVarQueryParams.Add("resource_image_tag", parameterToString(*r.resourceImageTag, ""))
	}
	if r.resourceRegistry != nil {
		localVarQueryParams.Add("resource_registry", parameterToString(*r.resourceRegistry, ""))
	}
	if r.resourceRepository != nil {
		localVarQueryParams.Add("resource_repository", parameterToString(*r.resourceRepository, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorrectionByUuidRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	uuid string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetCorrectionByUuidRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetCorrectionByUuidRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetCorrectionByUuidRequest) Execute() (*Correction, *http.Response, error) {
	return r.ApiService.GetCorrectionByUuidExecute(r)
}

/*
GetCorrectionByUuid Retrieve a correction by UUID

Returns a single correction, looked up via it's uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetCorrectionByUuidRequest
*/
func (a *DefaultApiService) GetCorrectionByUuid(ctx context.Context, uuid string) ApiGetCorrectionByUuidRequest {
	return ApiGetCorrectionByUuidRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Correction
func (a *DefaultApiService) GetCorrectionByUuidExecute(r ApiGetCorrectionByUuidRequest) (*Correction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Correction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCorrectionByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corrections/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCorrectionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	correctionType *string
	xNextlinuxAccount *string
}

func (r ApiGetCorrectionsRequest) CorrectionType(correctionType string) ApiGetCorrectionsRequest {
	r.correctionType = &correctionType
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetCorrectionsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetCorrectionsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetCorrectionsRequest) Execute() ([]Correction, *http.Response, error) {
	return r.ApiService.GetCorrectionsExecute(r)
}

/*
GetCorrections Retrieve a list of corrections

Returns a list of corrections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCorrectionsRequest
*/
func (a *DefaultApiService) GetCorrections(ctx context.Context) ApiGetCorrectionsRequest {
	return ApiGetCorrectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Correction
func (a *DefaultApiService) GetCorrectionsExecute(r ApiGetCorrectionsRequest) ([]Correction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Correction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCorrections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corrections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.correctionType != nil {
		localVarQueryParams.Add("correction_type", parameterToString(*r.correctionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageAncestorsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imageDigest string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageAncestorsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetImageAncestorsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetImageAncestorsRequest) Execute() ([]ImageAncestor, *http.Response, error) {
	return r.ApiService.GetImageAncestorsExecute(r)
}

/*
GetImageAncestors Return the list of ancestor images for the given image

Returns list of ancestor images, which are the images that form the base layers of the image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageAncestorsRequest
*/
func (a *DefaultApiService) GetImageAncestors(ctx context.Context, imageDigest string) ApiGetImageAncestorsRequest {
	return ApiGetImageAncestorsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []ImageAncestor
func (a *DefaultApiService) GetImageAncestorsExecute(r ApiGetImageAncestorsRequest) ([]ImageAncestor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ImageAncestor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetImageAncestors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/ancestors"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageInventoryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	inventoryType *string
	imageDigest *string
	context *string
	xNextlinuxAccount *string
}

func (r ApiGetImageInventoryRequest) InventoryType(inventoryType string) ApiGetImageInventoryRequest {
	r.inventoryType = &inventoryType
	return r
}
func (r ApiGetImageInventoryRequest) ImageDigest(imageDigest string) ApiGetImageInventoryRequest {
	r.imageDigest = &imageDigest
	return r
}
func (r ApiGetImageInventoryRequest) Context(context string) ApiGetImageInventoryRequest {
	r.context = &context
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageInventoryRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetImageInventoryRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetImageInventoryRequest) Execute() ([]InventoryItem, *http.Response, error) {
	return r.ApiService.GetImageInventoryExecute(r)
}

/*
GetImageInventory Return a list of the images in inventories for this account

Returns a list of the images that are in use

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetImageInventoryRequest
*/
func (a *DefaultApiService) GetImageInventory(ctx context.Context) ApiGetImageInventoryRequest {
	return ApiGetImageInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryItem
func (a *DefaultApiService) GetImageInventoryExecute(r ApiGetImageInventoryRequest) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetImageInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inventoryType != nil {
		localVarQueryParams.Add("inventory_type", parameterToString(*r.inventoryType, ""))
	}
	if r.imageDigest != nil {
		localVarQueryParams.Add("image_digest", parameterToString(*r.imageDigest, ""))
	}
	if r.context != nil {
		localVarQueryParams.Add("context", parameterToString(*r.context, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImagePolicyCheckByDigestRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imageDigest string
	tag *string
	policyId *string
	detail *bool
	history *bool
	interactive *bool
	baseDigest *string
	xNextlinuxAccount *string
}

func (r ApiGetImagePolicyCheckByDigestRequest) Tag(tag string) ApiGetImagePolicyCheckByDigestRequest {
	r.tag = &tag
	return r
}
func (r ApiGetImagePolicyCheckByDigestRequest) PolicyId(policyId string) ApiGetImagePolicyCheckByDigestRequest {
	r.policyId = &policyId
	return r
}
func (r ApiGetImagePolicyCheckByDigestRequest) Detail(detail bool) ApiGetImagePolicyCheckByDigestRequest {
	r.detail = &detail
	return r
}
func (r ApiGetImagePolicyCheckByDigestRequest) History(history bool) ApiGetImagePolicyCheckByDigestRequest {
	r.history = &history
	return r
}
func (r ApiGetImagePolicyCheckByDigestRequest) Interactive(interactive bool) ApiGetImagePolicyCheckByDigestRequest {
	r.interactive = &interactive
	return r
}
// Digest of a base image. If specified the evaluation will indicate results inherited from the base image
func (r ApiGetImagePolicyCheckByDigestRequest) BaseDigest(baseDigest string) ApiGetImagePolicyCheckByDigestRequest {
	r.baseDigest = &baseDigest
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImagePolicyCheckByDigestRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetImagePolicyCheckByDigestRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) Execute() ([]interface{}, *http.Response, error) {
	return r.ApiService.GetImagePolicyCheckByDigestExecute(r)
}

/*
GetImagePolicyCheckByDigest Check policy evaluation status for image

Get the policy evaluation for the given image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImagePolicyCheckByDigestRequest
*/
func (a *DefaultApiService) GetImagePolicyCheckByDigest(ctx context.Context, imageDigest string) ApiGetImagePolicyCheckByDigestRequest {
	return ApiGetImagePolicyCheckByDigestRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []interface{}
func (a *DefaultApiService) GetImagePolicyCheckByDigestExecute(r ApiGetImagePolicyCheckByDigestRequest) ([]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetImagePolicyCheckByDigest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{imageDigest}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"imageDigest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	if r.policyId != nil {
		localVarQueryParams.Add("policyId", parameterToString(*r.policyId, ""))
	}
	localVarQueryParams.Add("tag", parameterToString(*r.tag, ""))
	if r.detail != nil {
		localVarQueryParams.Add("detail", parameterToString(*r.detail, ""))
	}
	if r.history != nil {
		localVarQueryParams.Add("history", parameterToString(*r.history, ""))
	}
	if r.interactive != nil {
		localVarQueryParams.Add("interactive", parameterToString(*r.interactive, ""))
	}
	if r.baseDigest != nil {
		localVarQueryParams.Add("base_digest", parameterToString(*r.baseDigest, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageVulnerabilitiesByDigestRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imageDigest string
	vtype string
	forceRefresh *bool
	vendorOnly *bool
	baseDigest *string
	xNextlinuxAccount *string
}

func (r ApiGetImageVulnerabilitiesByDigestRequest) ForceRefresh(forceRefresh bool) ApiGetImageVulnerabilitiesByDigestRequest {
	r.forceRefresh = &forceRefresh
	return r
}
// Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data. When set to true, it will filter out all vulnerabilities where &#x60;will_not_fix&#x60; is False. If false all vulnerabilities are returned regardless of &#x60;will_not_fix&#x60;
func (r ApiGetImageVulnerabilitiesByDigestRequest) VendorOnly(vendorOnly bool) ApiGetImageVulnerabilitiesByDigestRequest {
	r.vendorOnly = &vendorOnly
	return r
}
// Digest of a base image. If specified the vulnerabilities will indicate inheritance from the base image
func (r ApiGetImageVulnerabilitiesByDigestRequest) BaseDigest(baseDigest string) ApiGetImageVulnerabilitiesByDigestRequest {
	r.baseDigest = &baseDigest
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageVulnerabilitiesByDigestRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetImageVulnerabilitiesByDigestRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetImageVulnerabilitiesByDigestRequest) Execute() (*EnterpriseVulnerabilityResponse, *http.Response, error) {
	return r.ApiService.GetImageVulnerabilitiesByDigestExecute(r)
}

/*
GetImageVulnerabilitiesByDigest Get vulnerabilities by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @param vtype
 @return ApiGetImageVulnerabilitiesByDigestRequest
*/
func (a *DefaultApiService) GetImageVulnerabilitiesByDigest(ctx context.Context, imageDigest string, vtype string) ApiGetImageVulnerabilitiesByDigestRequest {
	return ApiGetImageVulnerabilitiesByDigestRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
		vtype: vtype,
	}
}

// Execute executes the request
//  @return EnterpriseVulnerabilityResponse
func (a *DefaultApiService) GetImageVulnerabilitiesByDigestExecute(r ApiGetImageVulnerabilitiesByDigestRequest) (*EnterpriseVulnerabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseVulnerabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetImageVulnerabilitiesByDigest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{imageDigest}/vuln/{vtype}"
	localVarPath = strings.Replace(localVarPath, "{"+"imageDigest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vtype"+"}", url.PathEscape(parameterToString(r.vtype, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("force_refresh", parameterToString(*r.forceRefresh, ""))
	}
	if r.vendorOnly != nil {
		localVarQueryParams.Add("vendor_only", parameterToString(*r.vendorOnly, ""))
	}
	if r.baseDigest != nil {
		localVarQueryParams.Add("base_digest", parameterToString(*r.baseDigest, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImportSourcesSbomRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	operationId string
}


func (r ApiGetImportSourcesSbomRequest) Execute() (*SourceImportContentResponse, *http.Response, error) {
	return r.ApiService.GetImportSourcesSbomExecute(r)
}

/*
GetImportSourcesSbom list the packages of an imported source code repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operationId
 @return ApiGetImportSourcesSbomRequest
*/
func (a *DefaultApiService) GetImportSourcesSbom(ctx context.Context, operationId string) ApiGetImportSourcesSbomRequest {
	return ApiGetImportSourcesSbomRequest{
		ApiService: a,
		ctx: ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//  @return SourceImportContentResponse
func (a *DefaultApiService) GetImportSourcesSbomExecute(r ApiGetImportSourcesSbomRequest) (*SourceImportContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceImportContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetImportSourcesSbom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources/{operation_id}/sbom"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterToString(r.operationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInventoryClusterByNameRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	clusterName string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetInventoryClusterByNameRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetInventoryClusterByNameRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetInventoryClusterByNameRequest) Execute() (*InventoryCluster, *http.Response, error) {
	return r.ApiService.GetInventoryClusterByNameExecute(r)
}

/*
GetInventoryClusterByName Return a configured inventory cluster

Returns a cluster that is configured for reporting image inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName
 @return ApiGetInventoryClusterByNameRequest
*/
func (a *DefaultApiService) GetInventoryClusterByName(ctx context.Context, clusterName string) ApiGetInventoryClusterByNameRequest {
	return ApiGetInventoryClusterByNameRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return InventoryCluster
func (a *DefaultApiService) GetInventoryClusterByNameExecute(r ApiGetInventoryClusterByNameRequest) (*InventoryCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetInventoryClusterByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories/clusters/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterToString(r.clusterName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOperationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	operationId string
}


func (r ApiGetOperationRequest) Execute() (*SourceImportOperation, *http.Response, error) {
	return r.ApiService.GetOperationExecute(r)
}

/*
GetOperation Get detail on a single import

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operationId
 @return ApiGetOperationRequest
*/
func (a *DefaultApiService) GetOperation(ctx context.Context, operationId string) ApiGetOperationRequest {
	return ApiGetOperationRequest{
		ApiService: a,
		ctx: ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//  @return SourceImportOperation
func (a *DefaultApiService) GetOperationExecute(r ApiGetOperationRequest) (*SourceImportOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceImportOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterToString(r.operationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuntimeComplianceChecksRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	imageDigest *string
	xNextlinuxAccount *string
}

func (r ApiGetRuntimeComplianceChecksRequest) ImageDigest(imageDigest string) ApiGetRuntimeComplianceChecksRequest {
	r.imageDigest = &imageDigest
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetRuntimeComplianceChecksRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetRuntimeComplianceChecksRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetRuntimeComplianceChecksRequest) Execute() ([]RuntimeComplianceCheck, *http.Response, error) {
	return r.ApiService.GetRuntimeComplianceChecksExecute(r)
}

/*
GetRuntimeComplianceChecks Get all runtime compliance checks or just those for a given image digest

Get all runtime compliance checks or just those for a given image digest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRuntimeComplianceChecksRequest
*/
func (a *DefaultApiService) GetRuntimeComplianceChecks(ctx context.Context) ApiGetRuntimeComplianceChecksRequest {
	return ApiGetRuntimeComplianceChecksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RuntimeComplianceCheck
func (a *DefaultApiService) GetRuntimeComplianceChecksExecute(r ApiGetRuntimeComplianceChecksRequest) ([]RuntimeComplianceCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RuntimeComplianceCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRuntimeComplianceChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtime_compliance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageDigest != nil {
		localVarQueryParams.Add("image_digest", parameterToString(*r.imageDigest, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuntimeComplianceResultRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	complianceFileId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetRuntimeComplianceResultRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetRuntimeComplianceResultRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetRuntimeComplianceResultRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.GetRuntimeComplianceResultExecute(r)
}

/*
GetRuntimeComplianceResult Check the results of a a specific runtime compliance check

Get the results of a specific runtime compliance check

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param complianceFileId
 @return ApiGetRuntimeComplianceResultRequest
*/
func (a *DefaultApiService) GetRuntimeComplianceResult(ctx context.Context, complianceFileId string) ApiGetRuntimeComplianceResultRequest {
	return ApiGetRuntimeComplianceResultRequest{
		ApiService: a,
		ctx: ctx,
		complianceFileId: complianceFileId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DefaultApiService) GetRuntimeComplianceResultExecute(r ApiGetRuntimeComplianceResultRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRuntimeComplianceResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtime_compliance/result/{compliance_file_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"compliance_file_id"+"}", url.PathEscape(parameterToString(r.complianceFileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
}


func (r ApiGetSourceRequest) Execute() (*SourceManifest, *http.Response, error) {
	return r.ApiService.GetSourceExecute(r)
}

/*
GetSource Get a detailed source repository analysis metadata record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @return ApiGetSourceRequest
*/
func (a *DefaultApiService) GetSource(ctx context.Context, sourceId string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return SourceManifest
func (a *DefaultApiService) GetSourceExecute(r ApiGetSourceRequest) (*SourceManifest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceManifest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceContentByTypeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
	contentType string
}


func (r ApiGetSourceContentByTypeRequest) Execute() (*ContentPackageResponse, *http.Response, error) {
	return r.ApiService.GetSourceContentByTypeExecute(r)
}

/*
GetSourceContentByType Get the content of an analyzed source repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @param contentType
 @return ApiGetSourceContentByTypeRequest
*/
func (a *DefaultApiService) GetSourceContentByType(ctx context.Context, sourceId string, contentType string) ApiGetSourceContentByTypeRequest {
	return ApiGetSourceContentByTypeRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
		contentType: contentType,
	}
}

// Execute executes the request
//  @return ContentPackageResponse
func (a *DefaultApiService) GetSourceContentByTypeExecute(r ApiGetSourceContentByTypeRequest) (*ContentPackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentPackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceContentByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/content/{content_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"content_type"+"}", url.PathEscape(parameterToString(r.contentType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceContentTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
}


func (r ApiGetSourceContentTypesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSourceContentTypesExecute(r)
}

/*
GetSourceContentTypes Get a detailed source repository analysis metadata record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @return ApiGetSourceContentTypesRequest
*/
func (a *DefaultApiService) GetSourceContentTypes(ctx context.Context, sourceId string) ApiGetSourceContentTypesRequest {
	return ApiGetSourceContentTypesRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetSourceContentTypesExecute(r ApiGetSourceContentTypesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceContentTypes")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSourceSbomNativeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
}


func (r ApiGetSourceSbomNativeRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.GetSourceSbomNativeExecute(r)
}

/*
GetSourceSbomNative Method for GetSourceSbomNative

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @return ApiGetSourceSbomNativeRequest
*/
func (a *DefaultApiService) GetSourceSbomNative(ctx context.Context, sourceId string) ApiGetSourceSbomNativeRequest {
	return ApiGetSourceSbomNativeRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DefaultApiService) GetSourceSbomNativeExecute(r ApiGetSourceSbomNativeRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceSbomNative")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/sbom/native"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/gzip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceSbomTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
}


func (r ApiGetSourceSbomTypesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetSourceSbomTypesExecute(r)
}

/*
GetSourceSbomTypes Get a detailed source repository analysis metadata record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @return ApiGetSourceSbomTypesRequest
*/
func (a *DefaultApiService) GetSourceSbomTypes(ctx context.Context, sourceId string) ApiGetSourceSbomTypesRequest {
	return ApiGetSourceSbomTypesRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetSourceSbomTypesExecute(r ApiGetSourceSbomTypesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceSbomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/sbom"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceVulnerabilitiesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
	vtype string
	forceRefresh *bool
	willNotFix *bool
	xNextlinuxAccount *string
}

func (r ApiGetSourceVulnerabilitiesRequest) ForceRefresh(forceRefresh bool) ApiGetSourceVulnerabilitiesRequest {
	r.forceRefresh = &forceRefresh
	return r
}
// Vulnerability data publishers explicitly won&#39;t fix some vulnerabilities. This is captured by will_not_fix attribute of each result. If the query parameter is set, results matching it&#39;s value will be filtered. Results are not filtered if the query parameter is unset
func (r ApiGetSourceVulnerabilitiesRequest) WillNotFix(willNotFix bool) ApiGetSourceVulnerabilitiesRequest {
	r.willNotFix = &willNotFix
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetSourceVulnerabilitiesRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetSourceVulnerabilitiesRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetSourceVulnerabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSourceVulnerabilitiesExecute(r)
}

/*
GetSourceVulnerabilities Get vulnerabilities for the source by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @param vtype
 @return ApiGetSourceVulnerabilitiesRequest
*/
func (a *DefaultApiService) GetSourceVulnerabilities(ctx context.Context, sourceId string, vtype string) ApiGetSourceVulnerabilitiesRequest {
	return ApiGetSourceVulnerabilitiesRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
		vtype: vtype,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetSourceVulnerabilitiesExecute(r ApiGetSourceVulnerabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceVulnerabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/vuln/{vtype}"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vtype"+"}", url.PathEscape(parameterToString(r.vtype, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("force_refresh", parameterToString(*r.forceRefresh, ""))
	}
	if r.willNotFix != nil {
		localVarQueryParams.Add("will_not_fix", parameterToString(*r.willNotFix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSourceVulnerabilityTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sourceId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetSourceVulnerabilityTypesRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiGetSourceVulnerabilityTypesRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiGetSourceVulnerabilityTypesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetSourceVulnerabilityTypesExecute(r)
}

/*
GetSourceVulnerabilityTypes Get the available vulnerability types for source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId
 @return ApiGetSourceVulnerabilityTypesRequest
*/
func (a *DefaultApiService) GetSourceVulnerabilityTypes(ctx context.Context, sourceId string) ApiGetSourceVulnerabilityTypesRequest {
	return ApiGetSourceVulnerabilityTypesRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetSourceVulnerabilityTypesExecute(r ApiGetSourceVulnerabilityTypesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSourceVulnerabilityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources/{source_id}/vuln"
	localVarPath = strings.Replace(localVarPath, "{"+"source_id"+"}", url.PathEscape(parameterToString(r.sourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInvalidateOperationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	operationId string
}


func (r ApiInvalidateOperationRequest) Execute() (*SourceImportOperation, *http.Response, error) {
	return r.ApiService.InvalidateOperationExecute(r)
}

/*
InvalidateOperation Invalidate operation ID so it can be garbage collected

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operationId
 @return ApiInvalidateOperationRequest
*/
func (a *DefaultApiService) InvalidateOperation(ctx context.Context, operationId string) ApiInvalidateOperationRequest {
	return ApiInvalidateOperationRequest{
		ApiService: a,
		ctx: ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//  @return SourceImportOperation
func (a *DefaultApiService) InvalidateOperationExecute(r ApiInvalidateOperationRequest) (*SourceImportOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceImportOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InvalidateOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterToString(r.operationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListArtifactsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	artifactTypes *[]string
	xNextlinuxAccount *string
}

func (r ApiListArtifactsRequest) ArtifactTypes(artifactTypes []string) ApiListArtifactsRequest {
	r.artifactTypes = &artifactTypes
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiListArtifactsRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiListArtifactsRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiListArtifactsRequest) Execute() (*ArtifactListResponse, *http.Response, error) {
	return r.ApiService.ListArtifactsExecute(r)
}

/*
ListArtifacts List artifacts present on a given application version

List artifacts present on a given application version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiListArtifactsRequest
*/
func (a *DefaultApiService) ListArtifacts(ctx context.Context, applicationId string, applicationVersionId string) ApiListArtifactsRequest {
	return ApiListArtifactsRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
//  @return ArtifactListResponse
func (a *DefaultApiService) ListArtifactsExecute(r ApiListArtifactsRequest) (*ArtifactListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListArtifacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.artifactTypes != nil {
		localVarQueryParams.Add("artifact_types", parameterToString(*r.artifactTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListInventoryClustersRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	inventoryType *string
	xNextlinuxAccount *string
}

func (r ApiListInventoryClustersRequest) InventoryType(inventoryType string) ApiListInventoryClustersRequest {
	r.inventoryType = &inventoryType
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiListInventoryClustersRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiListInventoryClustersRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiListInventoryClustersRequest) Execute() ([]InventoryCluster, *http.Response, error) {
	return r.ApiService.ListInventoryClustersExecute(r)
}

/*
ListInventoryClusters Return a list of the configured inventory clusters

Returns a filterable list of the clusters that are configured for reporting image inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListInventoryClustersRequest
*/
func (a *DefaultApiService) ListInventoryClusters(ctx context.Context) ApiListInventoryClustersRequest {
	return ApiListInventoryClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryCluster
func (a *DefaultApiService) ListInventoryClustersExecute(r ApiListInventoryClustersRequest) ([]InventoryCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListInventoryClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inventoryType != nil {
		localVarQueryParams.Add("inventory_type", parameterToString(*r.inventoryType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOperationsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiListOperationsRequest) Execute() ([]SourceImportOperation, *http.Response, error) {
	return r.ApiService.ListOperationsExecute(r)
}

/*
ListOperations Lists in-progress imports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOperationsRequest
*/
func (a *DefaultApiService) ListOperations(ctx context.Context) ApiListOperationsRequest {
	return ApiListOperationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SourceImportOperation
func (a *DefaultApiService) ListOperationsExecute(r ApiListOperationsRequest) ([]SourceImportOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SourceImportOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSourcesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}


func (r ApiListSourcesRequest) Execute() ([]Source, *http.Response, error) {
	return r.ApiService.ListSourcesExecute(r)
}

/*
ListSources List the source repository analysis records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSourcesRequest
*/
func (a *DefaultApiService) ListSources(ctx context.Context) ApiListSourcesRequest {
	return ApiListSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Source
func (a *DefaultApiService) ListSourcesExecute(r ApiListSourcesRequest) ([]Source, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Source
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveArtifactFromApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	associationId string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiRemoveArtifactFromApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiRemoveArtifactFromApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiRemoveArtifactFromApplicationVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveArtifactFromApplicationVersionExecute(r)
}

/*
RemoveArtifactFromApplicationVersion Delete an artifact from specified application version

Delete an artifact from specified application version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @param associationId
 @return ApiRemoveArtifactFromApplicationVersionRequest
*/
func (a *DefaultApiService) RemoveArtifactFromApplicationVersion(ctx context.Context, applicationId string, applicationVersionId string, associationId string) ApiRemoveArtifactFromApplicationVersionRequest {
	return ApiRemoveArtifactFromApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
		associationId: associationId,
	}
}

// Execute executes the request
func (a *DefaultApiService) RemoveArtifactFromApplicationVersionExecute(r ApiRemoveArtifactFromApplicationVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RemoveArtifactFromApplicationVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}/artifacts/{association_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"association_id"+"}", url.PathEscape(parameterToString(r.associationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncImageInventoryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	inventory *InventoryReport
	xNextlinuxAccount *string
}

func (r ApiSyncImageInventoryRequest) Inventory(inventory InventoryReport) ApiSyncImageInventoryRequest {
	r.inventory = &inventory
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiSyncImageInventoryRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiSyncImageInventoryRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiSyncImageInventoryRequest) Execute() ([]InventoryItem, *http.Response, error) {
	return r.ApiService.SyncImageInventoryExecute(r)
}

/*
SyncImageInventory synchronizes the list of the images in a given cluster for the inventory

synchronizes the list of the images that are in use

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncImageInventoryRequest
*/
func (a *DefaultApiService) SyncImageInventory(ctx context.Context) ApiSyncImageInventoryRequest {
	return ApiSyncImageInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InventoryItem
func (a *DefaultApiService) SyncImageInventoryExecute(r ApiSyncImageInventoryRequest) ([]InventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SyncImageInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventory == nil {
		return localVarReturnValue, nil, reportError("inventory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.inventory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	application *Application
	xNextlinuxAccount *string
}

func (r ApiUpdateApplicationRequest) Application(application Application) ApiUpdateApplicationRequest {
	r.application = &application
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiUpdateApplicationRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiUpdateApplicationRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiUpdateApplicationRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.UpdateApplicationExecute(r)
}

/*
UpdateApplication Update application details

Updates application details for given application_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @return ApiUpdateApplicationRequest
*/
func (a *DefaultApiService) UpdateApplication(ctx context.Context, applicationId string) ApiUpdateApplicationRequest {
	return ApiUpdateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return Application
func (a *DefaultApiService) UpdateApplicationExecute(r ApiUpdateApplicationRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.application == nil {
		return localVarReturnValue, nil, reportError("application is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.application
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationVersionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicationId string
	applicationVersionId string
	applicationVersion *ApplicationVersion
	xNextlinuxAccount *string
}

func (r ApiUpdateApplicationVersionRequest) ApplicationVersion(applicationVersion ApplicationVersion) ApiUpdateApplicationVersionRequest {
	r.applicationVersion = &applicationVersion
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiUpdateApplicationVersionRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiUpdateApplicationVersionRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiUpdateApplicationVersionRequest) Execute() (*ApplicationVersion, *http.Response, error) {
	return r.ApiService.UpdateApplicationVersionExecute(r)
}

/*
UpdateApplicationVersion Update application version details

Updates application version details for given application_id and application_version_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId
 @param applicationVersionId
 @return ApiUpdateApplicationVersionRequest
*/
func (a *DefaultApiService) UpdateApplicationVersion(ctx context.Context, applicationId string, applicationVersionId string) ApiUpdateApplicationVersionRequest {
	return ApiUpdateApplicationVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		applicationVersionId: applicationVersionId,
	}
}

// Execute executes the request
//  @return ApplicationVersion
func (a *DefaultApiService) UpdateApplicationVersionExecute(r ApiUpdateApplicationVersionRequest) (*ApplicationVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateApplicationVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_id}/versions/{application_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_version_id"+"}", url.PathEscape(parameterToString(r.applicationVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationVersion == nil {
		return localVarReturnValue, nil, reportError("applicationVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.applicationVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateComplianceViolationAlertStateRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	uuid string
	state string
	xNextlinuxAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiUpdateComplianceViolationAlertStateRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiUpdateComplianceViolationAlertStateRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiUpdateComplianceViolationAlertStateRequest) Execute() (*ComplianceViolationAlert, *http.Response, error) {
	return r.ApiService.UpdateComplianceViolationAlertStateExecute(r)
}

/*
UpdateComplianceViolationAlertState Open or close a compliance violation alert

Idempotent op for changing the alert state to open or closed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Identifier for the alert
 @param state
 @return ApiUpdateComplianceViolationAlertStateRequest
*/
func (a *DefaultApiService) UpdateComplianceViolationAlertState(ctx context.Context, uuid string, state string) ApiUpdateComplianceViolationAlertStateRequest {
	return ApiUpdateComplianceViolationAlertStateRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		state: state,
	}
}

// Execute executes the request
//  @return ComplianceViolationAlert
func (a *DefaultApiService) UpdateComplianceViolationAlertStateExecute(r ApiUpdateComplianceViolationAlertStateRequest) (*ComplianceViolationAlert, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComplianceViolationAlert
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateComplianceViolationAlertState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/compliance_violations/{uuid}/{state}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"state"+"}", url.PathEscape(parameterToString(r.state, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCorrectionByUuidRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	uuid string
	correction *Correction
	xNextlinuxAccount *string
}

func (r ApiUpdateCorrectionByUuidRequest) Correction(correction Correction) ApiUpdateCorrectionByUuidRequest {
	r.correction = &correction
	return r
}
// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiUpdateCorrectionByUuidRequest) XNextlinuxAccount(xNextlinuxAccount string) ApiUpdateCorrectionByUuidRequest {
	r.xNextlinuxAccount = &xNextlinuxAccount
	return r
}

func (r ApiUpdateCorrectionByUuidRequest) Execute() (*Correction, *http.Response, error) {
	return r.ApiService.UpdateCorrectionByUuidExecute(r)
}

/*
UpdateCorrectionByUuid Update a correction by UUID

Updates a single correction, looked up via it's uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateCorrectionByUuidRequest
*/
func (a *DefaultApiService) UpdateCorrectionByUuid(ctx context.Context, uuid string) ApiUpdateCorrectionByUuidRequest {
	return ApiUpdateCorrectionByUuidRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Correction
func (a *DefaultApiService) UpdateCorrectionByUuidExecute(r ApiUpdateCorrectionByUuidRequest) (*Correction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Correction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCorrectionByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corrections/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.correction == nil {
		return localVarReturnValue, nil, reportError("correction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNextlinuxAccount != nil {
		localVarHeaderParams["x-nextlinux-account"] = parameterToString(*r.xNextlinuxAccount, "")
	}
	// body params
	localVarPostBody = r.correction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadImportSourcesSbomRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	operationId string
	sbom *NativeSBOM
}

func (r ApiUploadImportSourcesSbomRequest) Sbom(sbom NativeSBOM) ApiUploadImportSourcesSbomRequest {
	r.sbom = &sbom
	return r
}

func (r ApiUploadImportSourcesSbomRequest) Execute() (*SourceImportContentResponse, *http.Response, error) {
	return r.ApiService.UploadImportSourcesSbomExecute(r)
}

/*
UploadImportSourcesSbom Begin the import of a source code repository analyzed by Syft into the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operationId
 @return ApiUploadImportSourcesSbomRequest
*/
func (a *DefaultApiService) UploadImportSourcesSbom(ctx context.Context, operationId string) ApiUploadImportSourcesSbomRequest {
	return ApiUploadImportSourcesSbomRequest{
		ApiService: a,
		ctx: ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//  @return SourceImportContentResponse
func (a *DefaultApiService) UploadImportSourcesSbomExecute(r ApiUploadImportSourcesSbomRequest) (*SourceImportContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceImportContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UploadImportSourcesSbom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imports/sources/{operation_id}/sbom"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterToString(r.operationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sbom == nil {
		return localVarReturnValue, nil, reportError("sbom is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sbom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
